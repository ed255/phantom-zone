use rand::{thread_rng, RngCore};
use itertools::Itertools;

fn u64_to_binary<const N: usize>(v: u64) -> [bool; N] {
    assert!((v as u128) < 2u128.pow(N as u32));
    let mut result = [false; N];
    for i in 0..N {
        if (v >> i) & 1 == 1 {
            result[i] = true;
        }
    }
    result
}

fn main() {
    set_parameter_set(ParameterSelector::NonInteractiveLTE2Party);
    // set application's common reference seed
    let mut seed = [0u8; 32];
    thread_rng().fill_bytes(&mut seed);
    set_common_reference_seed(seed);

    // let n_users = 100;
    let no_of_parties = 2;

    // Clide side //

    // Generate client keys
    let cks = (0..no_of_parties).map(|_| gen_client_key()).collect_vec();
    let ck_a = &cks[0];
    let ck_b = &cks[1];

    let input_a_int = 0x12;
    let input_b_int = 0x34;

    let input_a = u64_to_binary::<8>(input_a_int);
    let input_b = u64_to_binary::<8>(input_b_int);

    let now = std::time::Instant::now();
    let server_key_shares = cks
        .iter()
        .enumerate()
        .map(|(id, k)| gen_server_key_share(id, no_of_parties, k))
        .collect_vec();
    println!("Clients server key share gen time: {:?}", now.elapsed());

    // aggregate server shares and generate the server key
    let now = std::time::Instant::now();
    let server_key = aggregate_server_key_shares(&server_key_shares);
    server_key.set_server_key();
    println!("Server key gen time: {:?}", now.elapsed());

    // Server extracts the cyphertexts (1 cyphertext per bit)
    let now = std::time::Instant::now();
    let cts_a = ck_a.encrypt(input_a.as_slice());
    let cts_b = ck_b.encrypt(input_b.as_slice());
    println!("Encryption time: {:?}", now.elapsed());

    let now = std::time::Instant::now();
    let cts_a = cts_a.unseed::<Vec<Vec<u64>>>().key_switch(0).extract_all();
    let cts_b =  cts_b.unseed::<Vec<Vec<u64>>>().key_switch(1).extract_all();
    println!("Key switch time: {:?}", now.elapsed());

    let now = std::time::Instant::now();
    let cts_out = entrypoint(&cts_a, &cts_b);
    println!("FHE circuit evaluation time: {:?}", now.elapsed());

    let dec_shares = cts_out.iter().map(|ct| {
        cks
        .iter()
        .map(|k| k.gen_decryption_share(ct))
        .collect_vec()
    }).collect_vec();

    let out_back = cts_out.iter().zip(dec_shares.iter()).map(|(ct, dec_shares)| {
        cks[0].aggregate_decryption_shares(ct, dec_shares)
    }).collect_vec();

    println!("Result: {:?}", out_back);
}

